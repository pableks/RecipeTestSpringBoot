<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Edit Recipe</title>
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            font-family: Inter, system-ui, Avenir, Helvetica, Arial, sans-serif;
            line-height: 1.5;
            font-weight: 400;
            background: #e7f3ff;
        }

        .container {
            max-width: 500px;
            margin: 0 auto;
            padding: 20px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .list {
            display: flex;
            flex-direction: column;
            width: 100%;
            gap: 10px 0;
            max-height: fit-content;
        }

        .list__item {
            width: 100%;
            background: white;
            padding: 15px;
            border-radius: 5px;
            color: #001d29;
            font-weight: 500;
            font-size: 18px;
            font-size: 18px;
            max-height: calc(fit-content - 40px);
            display: flex;
            align-items: center;
            position: relative;
            will-change: transform;
        }

        .drag-handle {
            position: absolute;
            right: 0;
            width: 44px;
            height: 44px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .drag-handle::after {
            content: 'â ¿';
            font-size: 25px;
            color: #00000099;
        }

        .list__item.is-idle .drag-handle {
            cursor: grab;
        }

        .list__item.is-idle {
            transition: 0.25s ease transform;
        }

        .list__item.is-draggable,
        .list__item.is-draggable .drag-handle {
            cursor: grabbing;
        }

        .list__item.is-draggable {
            z-index: 10;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Edit Recipe</h1>
        
        <form th:action="@{/recipes/{id}(id=${recipe.id})}" th:object="${recipe}" method="post">
            <div class="form-group">
                <label for="name">Recipe Name:</label>
                <input type="text" id="name" th:field="*{name}" required />
            </div>
            
            <div class="form-group">
                <label for="preparationTime">Preparation Time (minutes):</label>
                <input type="number" id="preparationTime" th:field="*{preparationTime}" required />
            </div>
            
            <div class="form-group">
                <label for="difficulty">Difficulty:</label>
                <select id="difficulty" th:field="*{difficulty}">
                    <option value="Easy">Easy</option>
                    <option value="Medium">Medium</option>
                    <option value="Hard">Hard</option>
                </select>
            </div>
            
            <div class="form-group">
                <label>Ingredients:</label>
                <input type="text" id="ingredientInput" placeholder="Enter an ingredient" onkeypress="handleKeyPress(event, 'ingredient')">
                <button type="button" onclick="addIngredient()">Add Ingredient</button>
                <ul id="ingredientList" class="list js-list" data-list-type="ingredient"></ul>
                <input type="hidden" id="ingredientsInput" th:field="*{ingredients}">
            </div>
            
            <div class="form-group">
                <label>Preparation Steps:</label>
                <input type="text" id="stepInput" placeholder="Enter a preparation step" onkeypress="handleKeyPress(event, 'step')">
                <button type="button" onclick="addStep()">Add Step</button>
                <ol id="stepList" class="list js-list" data-list-type="step"></ol>
                <input type="hidden" id="preparationInput" th:field="*{preparation}">
            </div>
            
            <button type="submit">Edit Recipe</button>
        </form>
        
        <a th:href="@{/recipes}" class="back-link">Back to Recipes</a>
    </div>

    <script th:inline="javascript">
       let draggableItem;
let pointerStartY;
let itemsGap = 0;
let currentList;
let initialIndex;
let newPosition;
let isDragging = false;
let dragStartTimer;

function setup() {
    listContainers = document.querySelectorAll('.js-list');
    if (!listContainers.length) return;

    listContainers.forEach(container => {
        container.addEventListener('mousedown', handleDragStart);
        container.addEventListener('touchstart', handleDragStart, { passive: false });
    });

    document.addEventListener('mouseup', handleDragEnd);
    document.addEventListener('touchend', handleDragEnd);

    // Initialize lists with existing data
    const recipeIngredients = /*[[${recipe.ingredients}]]*/ '';
    const recipePreparation = /*[[${recipe.preparation}]]*/ '';
    
    initializeList('ingredientList', recipeIngredients);
    initializeList('stepList', recipePreparation);
}

function initializeList(listId, items) {
    const list = document.getElementById(listId);
    list.innerHTML = ''; // Clear existing items
    
    let parsedItems = parseItems(items);
    
    parsedItems.forEach((item, index) => {
        const listItem = createListItem(item, listId === 'stepList', index + 1);
        list.appendChild(listItem);
    });
    
    updateHiddenInput(listId);
    if (listId === 'stepList') {
        updateStepNumbers();
    }
}

function parseItems(items) {
    if (typeof items === 'string') {
        try {
            return JSON.parse(items);
        } catch (e) {
            // If it's not valid JSON, split by newlines
            return items.split('\n').map(item => item.trim()).filter(item => item !== '');
        }
    }
    return Array.isArray(items) ? items : [];
}

function handleDragStart(e) {
    if (e.type === 'mousedown' && e.button !== 0) return; // Only handle left mouse button

    const target = e.type === 'touchstart' ? document.elementFromPoint(e.touches[0].clientX, e.touches[0].clientY) : e.target;
    
    if (target.classList.contains('js-drag-handle')) {
        e.preventDefault(); // Prevent default for both mouse and touch events
        draggableItem = target.closest('.js-item');
        currentList = draggableItem.closest('.js-list');
        pointerStartY = e.clientY || e.touches[0].clientY;
        
        // Set a small delay before initiating drag
        dragStartTimer = setTimeout(() => {
            dragStart(e);
            if (e.type === 'mousedown') {
                document.addEventListener('mousemove', drag);
            } else {
                document.addEventListener('touchmove', drag, { passive: false });
            }
        }, 100);

        if (e.type === 'mousedown') {
            document.addEventListener('mouseup', cancelDragStart);
        } else {
            document.addEventListener('touchend', cancelDragStart);
        }
    }
}

function cancelDragStart() {
    clearTimeout(dragStartTimer);
    document.removeEventListener('mouseup', cancelDragStart);
    document.removeEventListener('touchend', cancelDragStart);
}

function dragStart(e) {
    if (!draggableItem) return;

    initialIndex = Array.from(currentList.children).indexOf(draggableItem);
    newPosition = initialIndex;

    setItemsGap();
    //disablePageScroll();
    initDraggableItem();
    draggableItem.style.zIndex = '1000';
}

function drag(e) {
    if (!draggableItem) return;

    e.preventDefault();
    isDragging = true;

    const clientY = e.clientY || e.touches[0].clientY;
    const pointerOffsetY = clientY - pointerStartY;

    draggableItem.style.transform = `translateY(${pointerOffsetY}px)`;

    updateIdleItemsStateAndPosition(pointerOffsetY);
    detectNewPosition(pointerOffsetY);
}

function handleDragEnd(e) {
    cancelDragStart();
    dragEnd();
}

function dragEnd() {
    if (!draggableItem) return;

    document.removeEventListener('mousemove', drag);
    document.removeEventListener('touchmove', drag);

    if (!isDragging) {
        cleanup();
        return;
    }

    isDragging = false;

    const items = Array.from(currentList.children);
    const currentIndex = items.indexOf(draggableItem);

    let finalY = 0;
    if (newPosition > currentIndex) {
        for (let i = currentIndex + 1; i <= newPosition; i++) {
            finalY += items[i].offsetHeight + itemsGap;
        }
    } else if (newPosition < currentIndex) {
        for (let i = newPosition; i < currentIndex; i++) {
            finalY -= items[i].offsetHeight + itemsGap;
        }
    }

    draggableItem.style.transition = 'transform 0.3s cubic-bezier(0.2, 0.8, 0.2, 1)';
    draggableItem.style.transform = `translateY(${finalY}px)`;

    setTimeout(() => {
        draggableItem.style.transition = '';
        draggableItem.style.transform = '';
        draggableItem.style.zIndex = '';
        if (newPosition !== initialIndex) {
            applyNewItemsOrder();
        } else {
            resetItemsPosition();
        }
        cleanup();
    }, 300);
}

function detectNewPosition(pointerOffsetY) {
    const items = Array.from(currentList.children);
    const draggableRect = draggableItem.getBoundingClientRect();
    const draggableCenter = draggableRect.top + draggableRect.height / 2;

    newPosition = initialIndex;

    for (let i = 0; i < items.length; i++) {
        if (items[i] === draggableItem) continue;
        const itemRect = items[i].getBoundingClientRect();
        const itemCenter = itemRect.top + itemRect.height / 2;
        if (draggableCenter < itemCenter && i < initialIndex) {
            newPosition = i;
            break;
        } else if (draggableCenter > itemCenter && i > initialIndex) {
            newPosition = i;
        }
    }
}

function updateIdleItemsStateAndPosition(pointerOffsetY) {
    const items = Array.from(currentList.children);
    const draggableRect = draggableItem.getBoundingClientRect();

    items.forEach((item, index) => {
        if (item === draggableItem) return;

        const itemRect = item.getBoundingClientRect();
        const itemCenter = itemRect.top + itemRect.height / 2;
        const draggableCenter = draggableRect.top + pointerOffsetY + draggableRect.height / 2;

        if (index < initialIndex && index >= newPosition && draggableCenter < itemCenter) {
            item.style.transform = `translateY(${draggableRect.height + itemsGap}px)`;
        } else if (index > initialIndex && index <= newPosition && draggableCenter > itemCenter) {
            item.style.transform = `translateY(-${draggableRect.height + itemsGap}px)`;
        } else {
            item.style.transform = '';
        }
    });
}

function applyNewItemsOrder() {
    const items = Array.from(currentList.children);
    items.splice(initialIndex, 1);
    items.splice(newPosition, 0, draggableItem);
    items.forEach(item => currentList.appendChild(item));

    if (currentList.id === 'stepList') {
        updateStepNumbers();
    }

    updateHiddenInput(currentList.id);
}

function resetItemsPosition() {
    const items = Array.from(currentList.children);
    items.forEach(item => {
        item.style.transform = '';
    });
}

function cleanup() {
    itemsGap = 0;
    unsetItemState();
    enablePageScroll();

    document.removeEventListener('mousemove', drag);
    document.removeEventListener('touchmove', drag);
    
    draggableItem = null;
    currentList = null;
    initialIndex = null;
    newPosition = null;
    isDragging = false;
}

function setItemsGap() {
    const idleItems = getIdleItems(currentList);
    if (idleItems.length <= 1) {
        itemsGap = 0;
        return;
    }

    const item1Rect = idleItems[0].getBoundingClientRect();
    const item2Rect = idleItems[1].getBoundingClientRect();

    itemsGap = Math.abs(item1Rect.bottom - item2Rect.top);
}

function disablePageScroll() {
    document.body.style.overflow = 'scroll';
    document.body.style.touchAction = 'none';
    document.body.style.userSelect = 'none';
}

function initDraggableItem() {
    draggableItem.classList.remove('is-idle');
    draggableItem.classList.add('is-draggable');
}

function unsetItemState() {
    getIdleItems(currentList).forEach((item) => {
        delete item.dataset.isAbove;
        delete item.dataset.isToggled;
        item.style.transform = '';
    });
    if (draggableItem) {
        draggableItem.classList.remove('is-draggable');
        draggableItem.classList.add('is-idle');
    }
}

function enablePageScroll() {
    document.body.style.overflow = '';
    document.body.style.touchAction = '';
    document.body.style.userSelect = '';
}

function getAllItems(list) {
    return Array.from(list.querySelectorAll('.js-item'));
}

function getIdleItems(list) {
    return getAllItems(list).filter((item) => item.classList.contains('is-idle'));
}

function handleKeyPress(event, type) {
    if (event.key === 'Enter') {
        event.preventDefault();
        if (type === 'ingredient') {
            addIngredient();
        } else if (type === 'step') {
            addStep();
        }
    }
}

function addIngredient() {
    const input = document.getElementById('ingredientInput');
    if (input.value.trim() !== '') {
        const list = document.getElementById('ingredientList');
        const listItem = createListItem(input.value, false);
        list.appendChild(listItem);
        input.value = '';
        updateHiddenInput('ingredientList');
    }
}

function addStep() {
    const input = document.getElementById('stepInput');
    if (input.value.trim() !== '') {
        const list = document.getElementById('stepList');
        const stepNumber = list.children.length + 1;
        const listItem = createListItem(input.value, true, stepNumber);
        list.appendChild(listItem);
        input.value = '';
        updateHiddenInput('stepList');
        updateStepNumbers();
    }
}

function createListItem(text, isStep, stepNumber) {
    const listItem = document.createElement('li');
    listItem.className = 'list__item is-idle js-item';
    listItem.innerHTML = `
        <span>${isStep ? `${stepNumber}. ${text}` : text}</span>
        <div class="drag-handle js-drag-handle"></div>
    `;
    return listItem;
}

function updateHiddenInput(listId) {
    const list = document.getElementById(listId);
    const items = Array.from(list.children).map(item => {
        const text = item.querySelector('span').textContent;
        return listId === 'stepList' ? text.replace(/^\d+\.\s*/, '') : text;
    });
    const hiddenInput = document.getElementById(listId === 'ingredientList' ? 'ingredientsInput' : 'preparationInput');
    hiddenInput.value = JSON.stringify(items);
}

function updateStepNumbers() {
    const stepList = document.getElementById('stepList');
    Array.from(stepList.children).forEach((item, index) => {
        const span = item.querySelector('span');
        span.textContent = `${index + 1}. ${span.textContent.replace(/^\d+\.\s*/, '')}`;
    });
}

// Call setup function when the DOM is fully loaded
document.querySelector('form').addEventListener('submit', function(e) {
    e.preventDefault();
    
    // Get the current values from the hidden inputs
    const ingredients = JSON.parse(document.getElementById('ingredientsInput').value);
    const preparation = JSON.parse(document.getElementById('preparationInput').value);
    
    // Set the values back to their original format
    document.getElementById('ingredientsInput').value = ingredients.join('\n');
    document.getElementById('preparationInput').value = preparation.join('\n');
    
    // Submit the form
    this.submit();
});

// Call setup function when the DOM is fully loaded
document.addEventListener('DOMContentLoaded', setup);
    </script>
</body>
</html>